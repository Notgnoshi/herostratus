use crate::achievement::{Achievement, AchievementDescriptor, Rule, RuleFactory};

/// Grant achievements for commits starting with
///
/// * `fixup!`, `squash!`, `amend!` (generated by `git commit --fixup|--squash`)
/// * `WIP:`, `TODO:`, `FIXME:` `DROPME:` (ad-hoc patterns that I've seen in the wild)
pub struct Fixup {
    descriptors: [AchievementDescriptor; 1],
}

impl Default for Fixup {
    fn default() -> Self {
        Self {
            descriptors: [AchievementDescriptor {
                enabled: true,
                id: 1,
                human_id: "fixup",
                name: "I'll fix that up later",
                description: "Prefix a commit message with a !fixup marker",
            }],
        }
    }
}

inventory::submit!(RuleFactory::default::<Fixup>());

const FIXUP_PREFIXES: &[&str] = &[
    "fixup!", "squash!", "amend!", "WIP", "TODO", "FIXME", "DROPME",
    // avoid false positives by accepting false negatives. Of all these patterns, "wip" is the one
    // that's most likely to be a part of a real word.
    "wip:", "todo", "fixme", "dropme",
];

impl Rule for Fixup {
    fn get_descriptors(&self) -> &[AchievementDescriptor] {
        &self.descriptors
    }
    fn get_descriptors_mut(&mut self) -> &mut [AchievementDescriptor] {
        &mut self.descriptors
    }
    fn process(&mut self, commit: &gix::Commit, _repo: &gix::Repository) -> Option<Achievement> {
        let summary = commit.message().ok()?.title;
        for pattern in FIXUP_PREFIXES {
            if summary.starts_with(pattern.as_bytes()) {
                return Some(Achievement {
                    name: "I'll fix that up later",
                    commit: commit.id,
                });
            }
        }
        None
    }
}
